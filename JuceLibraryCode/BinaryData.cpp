/* ==================================== JUCER_BINARY_RESOURCE ====================================

   This is an auto-generated file: Any edits you make may be overwritten!

*/

namespace BinaryData
{

//================== CHANGELOG ==================
static const unsigned char temp_binary_data_0[] =
"1.3.0 2012-07-18\n"
"  removed non-standard malloc.h from kiss_fft.h\n"
"\n"
"  moved -lm to end of link line\n"
"\n"
"  checked various return values\n"
"\n"
"  converted python Numeric code to NumPy\n"
" \n"
"  fixed test of int32_t on 64 bit OS\n"
"\n"
"  added padding in a couple of places to allow SIMD alignment of structs\n"
"\n"
"1.2.9 2010-05-27\n"
"  threadsafe ( including OpenMP )\n"
"\n"
"  first edition of kissfft.hh the C++ template fft engine\n"
" \n"
"1.2.8 \n"
"  Changed memory.h to string.h -- apparently more standard\n"
"  \n"
"  Added openmp extensions.  This can have fairly linear speedups for larger FFT sizes.\n"
"\n"
"1.2.7 \n"
"  Shrank the real-fft memory footprint. Thanks to Galen Seitz.\n"
"\n"
"1.2.6 (Nov 14, 2006) The \"thanks to GenArts\" release.\n"
"  Added multi-dimensional real-optimized FFT, see tools/kiss_fftndr\n"
"  Thanks go to GenArts, Inc. for sponsoring the development.\n"
"\n"
"1.2.5 (June 27, 2006) The \"release for no good reason\" release.\n"
"   Changed some harmless code to make some compilers' warnings go away.\n"
"   Added some more digits to pi -- why not.\n"
"   Added kiss_fft_next_fast_size() function to help people decide how much to pad.\n"
"   Changed multidimensional test from 8 dimensions to only 3 to avoid testing \n"
"   problems with fixed point (sorry Buckaroo Banzai).\n"
"\n"
"1.2.4 (Oct 27, 2005)   The \"oops, inverse fixed point real fft was borked\" release. \n"
"   Fixed scaling bug for inverse fixed point real fft -- also fixed test code that should've been failing.\n"
"    Thanks to Jean-Marc Valin for bug report.\n"
"\n"
"   Use sys/types.h for more portable types than short,int,long => int16_t,int32_t,int64_t\n"
"   If your system does not have these, you may need to define them -- but at least it breaks in a \n"
"   loud and easily fixable way -- unlike silently using the wrong size type.\n"
"\n"
"   Hopefully tools/psdpng.c is fixed -- thanks to Steve Kellog for pointing out the weirdness.\n"
"\n"
"1.2.3 (June 25, 2005)   The \"you want to use WHAT as a sample\" release.\n"
"    Added ability to use 32 bit fixed point samples -- requires a 64 bit intermediate result, a la 'long long'\n"
"\n"
"    Added ability to do 4 FFTs in parallel by using SSE SIMD instructions. This is accomplished by\n"
"    using the __m128 (vector of 4 floats) as kiss_fft_scalar.  Define USE_SIMD to use this.\n"
"    \n"
"    I know, I know ...  this is drifting a bit from the \"kiss\" principle, but the speed advantages \n"
"    make it worth it for some.  Also recent gcc makes it SOO easy to use vectors of 4 floats like a POD type.\n"
"\n"
"1.2.2 (May 6, 2005)   The Matthew release\n"
"    Replaced fixed point division with multiply&shift.  Thanks to Jean-Marc Valin for \n"
"    discussions regarding.  Considerable speedup for fixed-point.\n"
"\n"
"    Corrected overflow protection in real fft routines  when using fixed point.\n"
"    Finder's Credit goes to Robert Oschler of robodance for pointing me at the bug.\n"
"    This also led to the CHECK_OVERFLOW_OP macro.\n"
"\n"
"1.2.1 (April 4, 2004) \n"
"    compiles cleanly with just about every -W warning flag under the sun\n"
"\n"
"    reorganized kiss_fft_state so it could be read-only/const. This may be useful for embedded systems\n"
"    that are willing to predeclare twiddle factors, factorization.\n"
"\n"
"    Fixed C_MUL,S_MUL on 16-bit platforms.\n"
"\n"
"    tmpbuf will only be allocated if input & output buffers are same\n"
"    scratchbuf will only be allocated for ffts that are not multiples of 2,3,5\n"
" \n"
"    NOTE: The tmpbuf,scratchbuf changes may require synchronization code for multi-threaded apps.\n"
"\n"
"\n"
"1.2 (Feb 23, 2004)\n"
"    interface change -- cfg object is forward declaration of struct instead of void*\n"
"    This maintains type saftey and lets the compiler warn/error about stupid mistakes.\n"
"            (prompted by suggestion from Erik de Castro Lopo)\n"
"\n"
"    small speed improvements\n"
"\n"
"    added psdpng.c -- sample utility that will create png spectrum \"waterfalls\" from an input file\n"
"        ( not terribly useful yet)\n"
"\n"
"1.1.1 (Feb 1, 2004 )\n"
"    minor bug fix -- only affects odd rank, in-place, multi-dimensional FFTs\n"
"\n"
"1.1 : (Jan 30,2004)\n"
"    split sample_code/ into test/ and tools/\n"
"\n"
"    Removed 2-D fft and added N-D fft (arbitrary)\n"
"\n"
"    modified fftutil.c to allow multi-d FFTs\n"
"\n"
"    Modified core fft routine to allow an input stride via kiss_fft_stride()\n"
"    (eased support of multi-D ffts)\n"
"\n"
"    Added fast convolution filtering (FIR filtering using overlap-scrap method, with tail scrap)\n"
"\n"
"    Add kfc.[ch]: the KISS FFT Cache. It takes care of allocs for you ( suggested by Oscar Lesta ).\n"
"\n"
"1.0.1 (Dec 15, 2003)\n"
"    fixed bug that occurred when nfft==1. Thanks to Steven Johnson.\n"
"    \n"
"1.0 : (Dec 14, 2003)\n"
"    changed kiss_fft function from using a single buffer, to two buffers.\n"
"    If the same buffer pointer is supplied for both in and out, kiss will\n"
"    manage the buffer copies.\n"
"\n"
"    added kiss_fft2d and kiss_fftr as separate source files (declarations in kiss_fft.h )\n"
"\n"
"0.4 :(Nov 4,2003) optimized for radix 2,3,4,5\n"
"\n"
"0.3 :(Oct 28, 2003) woops, version 2 didn't actually factor out any radices other than 2.\n"
"        Thanks to Steven Johnson for finding this one.\n"
"\n"
"0.2 :(Oct 27, 2003) added mixed radix, only radix 2,4 optimized versions\n"
"\n"
"0.1 :(May 19 2003)  initial release, radix 2 only\n";

const char* CHANGELOG = (const char*) temp_binary_data_0;

//================== COPYING ==================
static const unsigned char temp_binary_data_1[] =
"Copyright (c) 2003-2010 Mark Borgerding\n"
"\n"
"All rights reserved.\n"
"\n"
"Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n"
"\n"
"    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n"
"    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n"
"    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n"
"\n"
"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO E"
"VENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR"
" BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH D"
"AMAGE.\n";

const char* COPYING = (const char*) temp_binary_data_1;

//================== Makefile ==================
static const unsigned char temp_binary_data_2[] =
"KFVER=130\n"
"\n"
"doc:\n"
"\t@echo \"Start by reading the README file.  If you want to build and test lots of stuff, do a 'make testall'\"\n"
"\t@echo \"but be aware that 'make testall' has dependencies that the basic kissfft software does not.\"\n"
"\t@echo \"It is generally unneeded to run these tests yourself, unless you plan on changing the inner workings\"\n"
"\t@echo \"of kissfft and would like to make use of its regression tests.\"\n"
"\n"
"testall:\n"
"\t# The simd and int32_t types may or may not work on your machine \n"
"\tmake -C test DATATYPE=simd CFLAGADD=\"$(CFLAGADD)\" test\n"
"\tmake -C test DATATYPE=int32_t CFLAGADD=\"$(CFLAGADD)\" test\n"
"\tmake -C test DATATYPE=int16_t CFLAGADD=\"$(CFLAGADD)\" test\n"
"\tmake -C test DATATYPE=float CFLAGADD=\"$(CFLAGADD)\" test\n"
"\tmake -C test DATATYPE=double CFLAGADD=\"$(CFLAGADD)\" test\n"
"\techo \"all tests passed\"\n"
"\n"
"tarball: clean\n"
"\thg archive -r v$(KFVER) -t tgz kiss_fft$(KFVER).tar.gz \n"
"\thg archive -r v$(KFVER) -t zip kiss_fft$(KFVER).zip\n"
"\n"
"clean:\n"
"\tcd test && make clean\n"
"\tcd tools && make clean\n"
"\trm -f kiss_fft*.tar.gz *~ *.pyc kiss_fft*.zip \n"
"\n"
"asm: kiss_fft.s\n"
"\n"
"kiss_fft.s: kiss_fft.c kiss_fft.h _kiss_fft_guts.h\n"
"\t[ -e kiss_fft.s ] && mv kiss_fft.s kiss_fft.s~ || true\n"
"\tgcc -S kiss_fft.c -O3 -mtune=native -ffast-math -fomit-frame-pointer -unroll-loops -dA -fverbose-asm \n"
"\tgcc -o kiss_fft_short.s -S kiss_fft.c -O3 -mtune=native -ffast-math -fomit-frame-pointer -dA -fverbose-asm -DFIXED_POINT\n"
"\t[ -e kiss_fft.s~ ] && diff kiss_fft.s~ kiss_fft.s || true\n";

const char* Makefile = (const char*) temp_binary_data_2;

//================== README ==================
static const unsigned char temp_binary_data_3[] =
"KISS FFT - A mixed-radix Fast Fourier Transform based up on the principle, \n"
"\"Keep It Simple, Stupid.\"\n"
"\n"
"    There are many great fft libraries already around.  Kiss FFT is not trying\n"
"to be better than any of them.  It only attempts to be a reasonably efficient, \n"
"moderately useful FFT that can use fixed or floating data types and can be \n"
"incorporated into someone's C program in a few minutes with trivial licensing.\n"
"\n"
"USAGE:\n"
"\n"
"    The basic usage for 1-d complex FFT is:\n"
"\n"
"        #include \"kiss_fft.h\"\n"
"\n"
"        kiss_fft_cfg cfg = kiss_fft_alloc( nfft ,is_inverse_fft ,0,0 );\n"
"\n"
"        while ...\n"
"        \n"
"            ... // put kth sample in cx_in[k].r and cx_in[k].i\n"
"            \n"
"            kiss_fft( cfg , cx_in , cx_out );\n"
"            \n"
"            ... // transformed. DC is in cx_out[0].r and cx_out[0].i \n"
"            \n"
"        free(cfg);\n"
"\n"
"    Note: frequency-domain data is stored from dc up to 2pi.\n"
"    so cx_out[0] is the dc bin of the FFT\n"
"    and cx_out[nfft/2] is the Nyquist bin (if exists)\n"
"\n"
"    Declarations are in \"kiss_fft.h\", along with a brief description of the \n"
"functions you'll need to use. \n"
"\n"
"Code definitions for 1d complex FFTs are in kiss_fft.c.\n"
"\n"
"You can do other cool stuff with the extras you'll find in tools/\n"
"\n"
"    * multi-dimensional FFTs \n"
"    * real-optimized FFTs  (returns the positive half-spectrum: (nfft/2+1) complex frequency bins)\n"
"    * fast convolution FIR filtering (not available for fixed point)\n"
"    * spectrum image creation\n"
"\n"
"The core fft and most tools/ code can be compiled to use float, double,\n"
" Q15 short or Q31 samples. The default is float.\n"
"\n"
"\n"
"BACKGROUND:\n"
"\n"
"    I started coding this because I couldn't find a fixed point FFT that didn't \n"
"use assembly code.  I started with floating point numbers so I could get the \n"
"theory straight before working on fixed point issues.  In the end, I had a \n"
"little bit of code that could be recompiled easily to do ffts with short, float\n"
"or double (other types should be easy too).  \n"
"\n"
"    Once I got my FFT working, I was curious about the speed compared to\n"
"a well respected and highly optimized fft library.  I don't want to criticize \n"
"this great library, so let's call it FFT_BRANDX.\n"
"During this process, I learned:\n"
"\n"
"    1. FFT_BRANDX has more than 100K lines of code. The core of kiss_fft is about 500 lines (cpx 1-d).\n"
"    2. It took me an embarrassingly long time to get FFT_BRANDX working.\n"
"    3. A simple program using FFT_BRANDX is 522KB. A similar program using kiss_fft is 18KB (without optimizing for size).\n"
"    4. FFT_BRANDX is roughly twice as fast as KISS FFT in default mode.\n"
"\n"
"    It is wonderful that free, highly optimized libraries like FFT_BRANDX exist.\n"
"But such libraries carry a huge burden of complexity necessary to extract every \n"
"last bit of performance.\n"
"\n"
"    Sometimes simpler is better, even if it's not better.\n"
"\n"
"FREQUENTLY ASKED QUESTIONS:\n"
"\tQ: Can I use kissfft in a project with a ___ license?\n"
"\tA: Yes.  See LICENSE below.\n"
"\n"
"\tQ: Why don't I get the output I expect?\n"
"\tA: The two most common causes of this are \n"
"\t\t1) scaling : is there a constant multiplier between what you got and what you want?\n"
"\t\t2) mixed build environment -- all code must be compiled with same preprocessor \n"
"\t\tdefinitions for FIXED_POINT and kiss_fft_scalar\n"
"\n"
"\tQ: Will you write/debug my code for me?\n"
"\tA: Probably not unless you pay me.  I am happy to answer pointed and topical questions, but \n"
"\tI may refer you to a book, a forum, or some other resource.\n"
"\n"
"\n"
"PERFORMANCE:\n"
"    (on Athlon XP 2100+, with gcc 2.96, float data type)\n"
"\n"
"    Kiss performed 10000 1024-pt cpx ffts in .63 s of cpu time.\n"
"    For comparison, it took md5sum twice as long to process the same amount of data.\n"
"\n"
"    Transforming 5 minutes of CD quality audio takes less than a second (nfft=1024). \n"
"\n"
"DO NOT:\n"
"    ... use Kiss if you need the Fastest Fourier Transform in the World\n"
"    ... ask me to add features that will bloat the code\n"
"\n"
"UNDER THE HOOD:\n"
"\n"
"    Kiss FFT uses a time decimation, mixed-radix, out-of-place FFT. If you give it an input buffer  \n"
"    and output buffer that are the same, a temporary buffer will be created to hold the data.\n"
"\n"
"    No static data is used.  The core routines of kiss_fft are thread-safe (but not all of the tools directory).\n"
"\n"
"    No scaling is done for the floating point version (for speed).  \n"
"    Scaling is done both ways for the fixed-point version (for overflow prevention).\n"
"\n"
"    Optimized butterflies are used for factors 2,3,4, and 5. \n"
"\n"
"    The real (i.e. not complex) optimization code only works for even length ffts.  It does two half-length\n"
"    FFTs in parallel (packed into real&imag), and then combines them via twiddling.  The result is \n"
"    nfft/2+1 complex frequency bins from DC to Nyquist.  If you don't know what this means, search the web.\n"
"\n"
"    The fast convolution filtering uses the overlap-scrap method, slightly \n"
"    modified to put the scrap at the tail.\n"
"\n"
"LICENSE:\n"
"    Revised BSD License, see COPYING for verbiage. \n"
"    Basically, \"free to use&change, give credit where due, no guarantees\"\n"
"    Note this license is compatible with GPL at one end of the spectrum and closed, commercial software at \n"
"    the other end.  See http://www.fsf.org/licensing/licenses\n"
"\n"
"    A commercial license is available which removes the requirement for attribution.  Contact me for details.\n"
"\n"
"  \n"
"TODO:\n"
"    *) Add real optimization for odd length FFTs \n"
"    *) Document/revisit the input/output fft scaling\n"
"    *) Make doc describing the overlap (tail) scrap fast convolution filtering in kiss_fastfir.c\n"
"    *) Test all the ./tools/ code with fixed point (kiss_fastfir.c doesn't work, maybe others)\n"
"\n"
"AUTHOR:\n"
"    Mark Borgerding\n"
"    Mark@Borgerding.net\n";

const char* README = (const char*) temp_binary_data_3;

//================== README.simd ==================
static const unsigned char temp_binary_data_4[] =
"If you are reading this, it means you think you may be interested in using the SIMD extensions in kissfft \n"
"to do 4 *separate* FFTs at once.\n"
"\n"
"Beware! Beyond here there be dragons!\n"
"\n"
"This API is not easy to use, is not well documented, and breaks the KISS principle.  \n"
"\n"
"\n"
"Still reading? Okay, you may get rewarded for your patience with a considerable speedup \n"
"(2-3x) on intel x86 machines with SSE if you are willing to jump through some hoops.\n"
"\n"
"The basic idea is to use the packed 4 float __m128 data type as a scalar element.  \n"
"This means that the format is pretty convoluted. It performs 4 FFTs per fft call on signals A,B,C,D.\n"
"\n"
"For complex data, the data is interlaced as follows:\n"
"rA0,rB0,rC0,rD0,      iA0,iB0,iC0,iD0,   rA1,rB1,rC1,rD1, iA1,iB1,iC1,iD1 ...\n"
"where \"rA0\" is the real part of the zeroth sample for signal A\n"
"\n"
"Real-only data is laid out:\n"
"rA0,rB0,rC0,rD0,     rA1,rB1,rC1,rD1,      ... \n"
"\n"
"Compile with gcc flags something like\n"
"-O3 -mpreferred-stack-boundary=4  -DUSE_SIMD=1 -msse \n"
"\n"
"Be aware of SIMD alignment.  This is the most likely cause of segfaults.  \n"
"The code within kissfft uses scratch variables on the stack.  \n"
"With SIMD, these must have addresses on 16 byte boundaries.  \n"
"Search on \"SIMD alignment\" for more info.\n"
"\n"
"\n"
"\n"
"Robin at Divide Concept was kind enough to share his code for formatting to/from the SIMD kissfft.  \n"
"I have not run it -- use it at your own risk.  It appears to do 4xN and Nx4 transpositions \n"
"(out of place).\n"
"\n"
"void SSETools::pack128(float* target, float* source, unsigned long size128)\n"
"{\n"
"   __m128* pDest = (__m128*)target;\n"
"   __m128* pDestEnd = pDest+size128;\n"
"   float* source0=source;\n"
"   float* source1=source0+size128;\n"
"   float* source2=source1+size128;\n"
"   float* source3=source2+size128;\n"
"\n"
"   while(pDest<pDestEnd)\n"
"   {\n"
"       *pDest=_mm_set_ps(*source3,*source2,*source1,*source0);\n"
"       source0++;\n"
"       source1++;\n"
"       source2++;\n"
"       source3++;\n"
"       pDest++;\n"
"   }\n"
"}\n"
"\n"
"void SSETools::unpack128(float* target, float* source, unsigned long size128)\n"
"{\n"
"\n"
"   float* pSrc = source;\n"
"   float* pSrcEnd = pSrc+size128*4;\n"
"   float* target0=target;\n"
"   float* target1=target0+size128;\n"
"   float* target2=target1+size128;\n"
"   float* target3=target2+size128;\n"
"\n"
"   while(pSrc<pSrcEnd)\n"
"   {\n"
"       *target0=pSrc[0];\n"
"       *target1=pSrc[1];\n"
"       *target2=pSrc[2];\n"
"       *target3=pSrc[3];\n"
"       target0++;\n"
"       target1++;\n"
"       target2++;\n"
"       target3++;\n"
"       pSrc+=4;\n"
"   }\n"
"} \n";

const char* README_simd = (const char*) temp_binary_data_4;

//================== compfft.py ==================
static const unsigned char temp_binary_data_5[] =
"#!/usr/bin/env python\n"
"\n"
"# use FFTPACK as a baseline\n"
"import FFT\n"
"from Numeric import *\n"
"import math\n"
"import random\n"
"import sys\n"
"import struct\n"
"import fft\n"
"\n"
"pi=math.pi\n"
"e=math.e\n"
"j=complex(0,1)\n"
"lims=(-32768,32767)\n"
"\n"
"def randbuf(n,cpx=1):\n"
"    res = array( [ random.uniform( lims[0],lims[1] ) for i in range(n) ] )\n"
"    if cpx:\n"
"        res = res + j*randbuf(n,0)\n"
"    return res\n"
"\n"
"def main():\n"
"    from getopt import getopt\n"
"    import popen2\n"
"    opts,args = getopt( sys.argv[1:],'u:n:Rt:' )\n"
"    opts=dict(opts)\n"
"    exitcode=0\n"
"\n"
"    util = opts.get('-u','./kf_float')\n"
"\n"
"    try:\n"
"        dims = [ int(d) for d in opts['-n'].split(',')]\n"
"        cpx = opts.get('-R') is None\n"
"        fmt=opts.get('-t','f')\n"
"    except KeyError:\n"
"        sys.stderr.write(\"\"\"\n"
"        usage: compfft.py \n"
"        -n d1[,d2,d3...]  : FFT dimension(s)\n"
"        -u utilname : see sample_code/fftutil.c, default = ./kf_float\n"
"        -R : real-optimized version\\n\"\"\")\n"
"        sys.exit(1)\n"
"\n"
"    x = fft.make_random( dims )\n"
"\n"
"    cmd = '%s -n %s ' % ( util, ','.join([ str(d) for d in dims]) )\n"
"    if cpx:\n"
"        xout = FFT.fftnd(x)\n"
"        xout = reshape(xout,(size(xout),))\n"
"    else:\n"
"        cmd += '-R '\n"
"        xout = FFT.real_fft(x)\n"
"\n"
"    proc = popen2.Popen3( cmd , bufsize=len(x) )\n"
"\n"
"    proc.tochild.write( dopack( x , fmt ,cpx ) )\n"
"    proc.tochild.close()\n"
"    xoutcomp = dounpack( proc.fromchild.read( ) , fmt ,1 )\n"
"    #xoutcomp = reshape( xoutcomp , dims )\n"
"\n"
"    sig = xout * conjugate(xout)\n"
"    sigpow = sum( sig )\n"
"\n"
"    diff = xout-xoutcomp\n"
"    noisepow = sum( diff * conjugate(diff) )\n"
"\n"
"    snr = 10 * math.log10(abs( sigpow / noisepow ) )\n"
"    if snr<100:\n"
"        print xout\n"
"        print xoutcomp\n"
"        exitcode=1\n"
"    print 'NFFT=%s,SNR = %f dB' % (str(dims),snr)\n"
"    sys.exit(exitcode)\n"
"\n"
"def dopack(x,fmt,cpx):\n"
"    x = reshape( x, ( size(x),) )\n"
"    if cpx:\n"
"        s = ''.join( [ struct.pack('ff',c.real,c.imag) for c in x ] )\n"
"    else:\n"
"        s = ''.join( [ struct.pack('f',c) for c in x ] )\n"
"    return s \n"
"\n"
"def dounpack(x,fmt,cpx):\n"
"    uf = fmt * ( len(x) / 4 )\n"
"    s = struct.unpack(uf,x)\n"
"    if cpx:\n"
"        return array(s[::2]) + array( s[1::2] )*j\n"
"    else:    \n"
"        return array(s )\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()\n";

const char* compfft_py = (const char*) temp_binary_data_5;

//================== fastfir.py ==================
static const unsigned char temp_binary_data_6[] =
"#!/usr/bin/env python\n"
"\n"
"from Numeric import *\n"
"from FFT import *\n"
"\n"
"def make_random(len):\n"
"    import random\n"
"    res=[]\n"
"    for i in range(int(len)):\n"
"        r=random.uniform(-1,1)\n"
"        i=random.uniform(-1,1)\n"
"        res.append( complex(r,i) )\n"
"    return res\n"
"\n"
"def slowfilter(sig,h):\n"
"    translen = len(h)-1\n"
"    return convolve(sig,h)[translen:-translen]\n"
"\n"
"def nextpow2(x):\n"
"    return 2 ** math.ceil(math.log(x)/math.log(2))\n"
"\n"
"def fastfilter(sig,h,nfft=None):\n"
"    if nfft is None:\n"
"        nfft = int( nextpow2( 2*len(h) ) )\n"
"    H = fft( h , nfft )\n"
"    scraplen = len(h)-1\n"
"    keeplen = nfft-scraplen\n"
"    res=[]\n"
"    isdone = 0\n"
"    lastidx = nfft\n"
"    idx0 = 0\n"
"    while not isdone:\n"
"        idx1 = idx0 + nfft\n"
"        if idx1 >= len(sig):\n"
"            idx1 = len(sig)\n"
"            lastidx = idx1-idx0\n"
"            if lastidx <= scraplen:\n"
"                break\n"
"            isdone = 1\n"
"        Fss = fft(sig[idx0:idx1],nfft)\n"
"        fm = Fss * H\n"
"        m = inverse_fft(fm)\n"
"        res.append( m[scraplen:lastidx] )\n"
"        idx0 += keeplen\n"
"    return concatenate( res )\n"
"\n"
"def main():\n"
"    import sys\n"
"    from getopt import getopt\n"
"    opts,args = getopt(sys.argv[1:],'rn:l:')\n"
"    opts=dict(opts)\n"
"\n"
"    siglen = int(opts.get('-l',1e4 ) )\n"
"    hlen =50 \n"
" \n"
"    nfft = int(opts.get('-n',128) )\n"
"    usereal = opts.has_key('-r')\n"
"\n"
"    print 'nfft=%d'%nfft\n"
"    # make a signal\n"
"    sig = make_random( siglen )\n"
"    # make an impulse response\n"
"    h = make_random( hlen )\n"
"    #h=[1]*2+[0]*3\n"
"    if usereal:\n"
"        sig=[c.real for c in sig]\n"
"        h=[c.real for c in h]\n"
"\n"
"    # perform MAC filtering\n"
"    yslow = slowfilter(sig,h)\n"
"    #print '<YSLOW>',yslow,'</YSLOW>'\n"
"    #yfast = fastfilter(sig,h,nfft)\n"
"    yfast = utilfastfilter(sig,h,nfft,usereal)\n"
"    #print yfast\n"
"    print 'len(yslow)=%d'%len(yslow)\n"
"    print 'len(yfast)=%d'%len(yfast)\n"
"    diff = yslow-yfast\n"
"    snr = 10*log10( abs( vdot(yslow,yslow) / vdot(diff,diff) ) )\n"
"    print 'snr=%s' % snr\n"
"    if snr < 10.0:\n"
"        print 'h=',h\n"
"        print 'sig=',sig[:5],'...'\n"
"        print 'yslow=',yslow[:5],'...'\n"
"        print 'yfast=',yfast[:5],'...'\n"
"\n"
"def utilfastfilter(sig,h,nfft,usereal):\n"
"    import compfft\n"
"    import os\n"
"    open( 'sig.dat','w').write( compfft.dopack(sig,'f',not usereal) )\n"
"    open( 'h.dat','w').write( compfft.dopack(h,'f',not usereal) )\n"
"    if usereal: \n"
"        util = './fastconvr' \n"
"    else:\n"
"        util = './fastconv'\n"
"    cmd = 'time %s -n %d -i sig.dat -h h.dat -o out.dat' % (util, nfft)\n"
"    print cmd\n"
"    ec  = os.system(cmd)\n"
"    print 'exited->',ec\n"
"    return compfft.dounpack(open('out.dat').read(),'f',not usereal)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()\n";

const char* fastfir_py = (const char*) temp_binary_data_6;

//================== fft.py ==================
static const unsigned char temp_binary_data_7[] =
"#!/usr/bin/env python\n"
"\n"
"import math\n"
"import sys\n"
"import random\n"
"\n"
"pi=math.pi\n"
"e=math.e\n"
"j=complex(0,1)\n"
"\n"
"def fft(f,inv):\n"
"    n=len(f)\n"
"    if n==1:\n"
"        return f\n"
"\n"
"    for p in 2,3,5:\n"
"        if n%p==0:\n"
"            break\n"
"    else:\n"
"        raise Exception('%s not factorable ' % n)\n"
"\n"
"    m = n/p\n"
"    Fout=[]\n"
"    for q in range(p): # 0,1\n"
"        fp = f[q::p]  # every p'th time sample\n"
"        Fp = fft( fp ,inv)\n"
"        Fout.extend( Fp )\n"
"\n"
"    for u in range(m):\n"
"        scratch = Fout[u::m] # u to end in strides of m\n"
"        for q1 in range(p):\n"
"            k = q1*m + u  # indices to Fout above that became scratch\n"
"            Fout[ k ] = scratch[0] # cuz e**0==1 in loop below\n"
"            for q in range(1,p):\n"
"                if inv:\n"
"                    t = e ** ( j*2*pi*k*q/n )\n"
"                else:                    \n"
"                    t = e ** ( -j*2*pi*k*q/n )\n"
"                Fout[ k ] += scratch[q] * t\n"
"\n"
"    return Fout\n"
"\n"
"def rifft(F):\n"
"    N = len(F) - 1\n"
"    Z = [0] * (N)\n"
"    for k in range(N):\n"
"        Fek = ( F[k] + F[-k-1].conjugate() )\n"
"        Fok = ( F[k] - F[-k-1].conjugate() ) * e ** (j*pi*k/N)\n"
"        Z[k] = Fek + j*Fok\n"
"\n"
"    fp = fft(Z , 1)\n"
"\n"
"    f = []\n"
"    for c in fp:\n"
"        f.append(c.real)\n"
"        f.append(c.imag)\n"
"    return f\n"
"\n"
"def real_fft( f,inv ):\n"
"    if inv:\n"
"        return rifft(f)\n"
"\n"
"    N = len(f) / 2\n"
"\n"
"    res = f[::2]\n"
"    ims = f[1::2]\n"
"\n"
"    fp = [ complex(r,i) for r,i in zip(res,ims) ]\n"
"    print 'fft input ', fp\n"
"    Fp = fft( fp ,0 )\n"
"    print 'fft output ', Fp\n"
"\n"
"    F = [ complex(0,0) ] * ( N+1 )\n"
"    \n"
"    F[0] = complex( Fp[0].real + Fp[0].imag , 0 ) \n"
"\n"
"    for k in range(1,N/2+1):\n"
"        tw = e ** ( -j*pi*(.5+float(k)/N ) )\n"
"        \n"
"        F1k = Fp[k] + Fp[N-k].conjugate()\n"
"        F2k = Fp[k] - Fp[N-k].conjugate()\n"
"        F2k *= tw\n"
"        F[k] = ( F1k + F2k ) * .5\n"
"        F[N-k] = ( F1k - F2k ).conjugate() * .5\n"
"        #F[N-k] = ( F1kp + e ** ( -j*pi*(.5+float(N-k)/N ) ) * F2kp ) * .5\n"
"        #F[N-k] = ( F1k.conjugate() - tw.conjugate() * F2k.conjugate() ) * .5\n"
"\n"
"    F[N] = complex( Fp[0].real - Fp[0].imag , 0 ) \n"
"    return F\n"
"\n"
"def main():\n"
"    #fft_func = fft\n"
"    fft_func = real_fft\n"
"\n"
"    tvec = [0.309655,0.815653,0.768570,0.591841,0.404767,0.637617,0.007803,0.012665]\n"
"    Ftvec = [ complex(r,i) for r,i in zip(\n"
"                [3.548571,-0.378761,-0.061950,0.188537,-0.566981,0.188537,-0.061950,-0.378761],\n"
"                [0.000000,-1.296198,-0.848764,0.225337,0.000000,-0.225337,0.848764,1.296198] ) ]\n"
"\n"
"    F = fft_func( tvec,0 )\n"
"\n"
"    nerrs= 0\n"
"    for i in range(len(Ftvec)/2 + 1):\n"
"        if abs( F[i] - Ftvec[i] )> 1e-5:\n"
"            print 'F[%d]: %s != %s' % (i,F[i],Ftvec[i])\n"
"            nerrs += 1\n"
"\n"
"    print '%d errors in forward fft' % nerrs\n"
"    if nerrs:\n"
"        return\n"
"\n"
"    trec = fft_func( F , 1 )\n"
"\n"
"    for i in range(len(trec) ):\n"
"        trec[i] /= len(trec)\n"
"\n"
"    for i in range(len(tvec) ):\n"
"        if abs( trec[i] - tvec[i] )> 1e-5:\n"
"            print 't[%d]: %s != %s' % (i,tvec[i],trec[i])\n"
"            nerrs += 1\n"
"\n"
"    print '%d errors in reverse fft' % nerrs\n"
"\n"
"\n"
"def make_random(dims=[1]):\n"
"    import Numeric \n"
"    res = []\n"
"    for i in range(dims[0]):\n"
"        if len(dims)==1:\n"
"            r=random.uniform(-1,1)\n"
"            i=random.uniform(-1,1)\n"
"            res.append( complex(r,i) )\n"
"        else:\n"
"            res.append( make_random( dims[1:] ) )\n"
"    return Numeric.array(res)\n"
"\n"
"def flatten(x):\n"
"    import Numeric\n"
"    ntotal = Numeric.product(Numeric.shape(x))\n"
"    return Numeric.reshape(x,(ntotal,))\n"
"\n"
"def randmat( ndims ):\n"
"    dims=[]\n"
"    for i in range( ndims ):\n"
"        curdim = int( random.uniform(2,4) )\n"
"        dims.append( curdim )\n"
"    return make_random(dims )\n"
"\n"
"def test_fftnd(ndims=3):\n"
"    import FFT\n"
"    import Numeric\n"
"\n"
"    x=randmat( ndims )\n"
"    print 'dimensions=%s' % str( Numeric.shape(x) )\n"
"    #print 'x=%s' %str(x)\n"
"    xver = FFT.fftnd(x)\n"
"    x2=myfftnd(x)\n"
"    err = xver - x2\n"
"    errf = flatten(err)\n"
"    xverf = flatten(xver)\n"
"    errpow = Numeric.vdot(errf,errf)+1e-10\n"
"    sigpow = Numeric.vdot(xverf,xverf)+1e-10\n"
"    snr = 10*math.log10(abs(sigpow/errpow) )\n"
"    if snr<80:\n"
"        print xver\n"
"        print x2\n"
"    print 'SNR=%sdB' % str( snr )\n"
" \n"
"def myfftnd(x):\n"
"    import Numeric\n"
"    xf = flatten(x)\n"
"    Xf = fftndwork( xf , Numeric.shape(x) )\n"
"    return Numeric.reshape(Xf,Numeric.shape(x) )\n"
"\n"
"def fftndwork(x,dims):\n"
"    import Numeric\n"
"    dimprod=Numeric.product( dims )\n"
"\n"
"    for k in range( len(dims) ):\n"
"        cur_dim=dims[ k ]\n"
"        stride=dimprod/cur_dim\n"
"        next_x = [complex(0,0)]*len(x)\n"
"        for i in range(stride):\n"
"            next_x[i*cur_dim:(i+1)*cur_dim] = fft(x[i:(i+cur_dim)*stride:stride],0)\n"
"        x = next_x\n"
"    return x\n"
"\n"
"if __name__ == \"__main__\":\n"
"    try:\n"
"        nd = int(sys.argv[1])\n"
"    except:\n"
"        nd=None\n"
"    if nd:    \n"
"        test_fftnd( nd )\n"
"    else:    \n"
"        sys.exit(0)\n";

const char* fft_py = (const char*) temp_binary_data_7;

//================== Makefile ==================
static const unsigned char temp_binary_data_8[] =
"\n"
"WARNINGS=-W -Wall -Wstrict-prototypes -Wmissing-prototypes -Waggregate-return \\\n"
"    -Wcast-align -Wcast-qual -Wnested-externs -Wshadow -Wbad-function-cast \\\n"
"    -Wwrite-strings\n"
"\n"
"CFLAGS=-O3 -I.. -I../tools $(WARNINGS)\n"
"CFLAGS+=-ffast-math -fomit-frame-pointer \n"
"#CFLAGS+=-funroll-loops\n"
"#CFLAGS+=-march=prescott \n"
"#CFLAGS+= -mtune=native \n"
"# TIP: try adding -openmp or -fopenmp  to enable OPENMP directives and use of multiple cores\n"
"#CFLAGS+=-fopenmp\n"
"CFLAGS+= $(CFLAGADD)\n"
"\n"
"\n"
"ifeq \"$(NFFT)\" \"\"\n"
" NFFT=1800\n"
"endif\n"
"ifeq \"$(NUMFFTS)\" \"\"\n"
" NUMFFTS=10000\n"
"endif\n"
"\n"
"ifeq \"$(DATATYPE)\" \"\"\n"
" DATATYPE=float\n"
"endif\n"
"\n"
"BENCHKISS=bm_kiss_$(DATATYPE)\n"
"BENCHFFTW=bm_fftw_$(DATATYPE)\n"
"SELFTEST=st_$(DATATYPE)\n"
"TESTREAL=tr_$(DATATYPE)\n"
"TESTKFC=tkfc_$(DATATYPE)\n"
"FASTFILTREAL=ffr_$(DATATYPE)\n"
"SELFTESTSRC=twotonetest.c\n"
"\n"
"\n"
"TYPEFLAGS=-Dkiss_fft_scalar=$(DATATYPE)\n"
"\n"
"ifeq  \"$(DATATYPE)\" \"int16_t\" \n"
" TYPEFLAGS=-DFIXED_POINT=16\n"
"endif\n"
"\n"
"ifeq  \"$(DATATYPE)\" \"int32_t\"\n"
" TYPEFLAGS=-DFIXED_POINT=32 \n"
"endif\n"
"\n"
"ifeq  \"$(DATATYPE)\" \"simd\"\n"
" TYPEFLAGS=-DUSE_SIMD=1 -msse\n"
"endif\n"
"\n"
"\n"
"ifeq  \"$(DATATYPE)\" \"float\"\n"
" # fftw needs to be built with --enable-float to build this lib\n"
" FFTWLIB=-lfftw3f\n"
"else\n"
" FFTWLIB=-lfftw3\n"
"endif\n"
"\n"
"FFTWLIBDIR=-L/usr/local/lib/\n"
"\n"
"SRCFILES=../kiss_fft.c ../tools/kiss_fftnd.c ../tools/kiss_fftr.c pstats.c ../tools/kfc.c ../tools/kiss_fftndr.c\n"
"\n"
"all: tools $(BENCHKISS) $(SELFTEST) $(BENCHFFTW) $(TESTREAL) $(TESTKFC)\n"
"\n"
"tools:\n"
"\tcd ../tools && make all\n"
"\n"
"\n"
"$(SELFTEST): $(SELFTESTSRC) $(SRCFILES)\n"
"\t$(CC) -o $@ $(CFLAGS) $(TYPEFLAGS) $+ -lm \n"
"\n"
"$(TESTKFC): $(SRCFILES) \n"
"\t$(CC) -o $@ $(CFLAGS)  -DKFC_TEST $(TYPEFLAGS) $+ -lm\n"
"\t\n"
"$(TESTREAL): test_real.c $(SRCFILES)\n"
"\t$(CC) -o $@ $(CFLAGS) $(TYPEFLAGS) $+ -lm\n"
"\n"
"$(BENCHKISS): benchkiss.c $(SRCFILES)\n"
"\t$(CC) -o $@ $(CFLAGS) $(TYPEFLAGS)  $+ -lm\n"
"\n"
"$(BENCHFFTW): benchfftw.c pstats.c\n"
"\t@echo \"======attempting to build FFTW benchmark\"\n"
"\t@$(CC) -o $@ $(CFLAGS) -DDATATYPE$(DATATYPE) $+ $(FFTWLIB) $(FFTWLIBDIR) -lm || echo \"FFTW not available for comparison\"\n"
"\n"
"test: all\n"
"\t@./$(TESTKFC)\n"
"\t@echo \"======1d & 2-d complex fft self test (type= $(DATATYPE) )\"\n"
"\t@./$(SELFTEST)\n"
"\t@echo \"======real FFT (type= $(DATATYPE) )\"\n"
"\t@./$(TESTREAL)\n"
"\t@echo \"======timing test (type=$(DATATYPE))\"\n"
"\t@./$(BENCHKISS) -x $(NUMFFTS) -n $(NFFT) \n"
"\t@[ -x ./$(BENCHFFTW) ] && ./$(BENCHFFTW) -x $(NUMFFTS) -n $(NFFT) ||true\n"
"\t@echo \"======higher dimensions type=$(DATATYPE))\"\n"
"\t@./testkiss.py\n"
"\n"
"selftest.c:\n"
"\t./mk_test.py 10 12 14 > selftest.c\n"
"selftest_short.c:\n"
"\t./mk_test.py -s 10 12 14 > selftest_short.c\n"
"\n"
"\n"
"CXXFLAGS=-O3 -ffast-math -fomit-frame-pointer  -I.. -I../tools -W -Wall\n"
"testcpp: testcpp.cc ../kissfft.hh\n"
"\t$(CXX) -o $@ $(CXXFLAGS) testcpp.cc -lm\n"
"\n"
"\n"
"clean:\n"
"\trm -f *~ bm_* st_* tr_* kf_* tkfc_* ff_* ffr_* *.pyc *.pyo *.dat testcpp\n";

const char* Makefile2 = (const char*) temp_binary_data_8;

//================== mk_test.py ==================
static const unsigned char temp_binary_data_9[] =
"#!/usr/bin/env python\n"
"\n"
"import FFT\n"
"import sys\n"
"import random\n"
"import re\n"
"j=complex(0,1)\n"
"\n"
"def randvec(n,iscomplex):\n"
"    if iscomplex:\n"
"        return [\n"
"                int(random.uniform(-32768,32767) ) + j*int(random.uniform(-32768,32767) )\n"
"                for i in range(n) ]\n"
"    else:                \n"
"        return [ int(random.uniform(-32768,32767) ) for i in range(n) ]\n"
"    \n"
"def c_format(v,round=0):\n"
"    if round:\n"
"        return ','.join( [ '{%d,%d}' %(int(c.real),int(c.imag) ) for c in v ] ) \n"
"    else:\n"
"        s= ','.join( [ '{%.60f ,%.60f }' %(c.real,c.imag) for c in v ] ) \n"
"        return re.sub(r'\\.?0+ ',' ',s)\n"
"\n"
"def test_cpx( n,inverse ,short):\n"
"    v = randvec(n,1)\n"
"    scale = 1\n"
"    if short:\n"
"        minsnr=30\n"
"    else:\n"
"        minsnr=100\n"
"\n"
"    if inverse:\n"
"        tvecout = FFT.inverse_fft(v)\n"
"        if short:\n"
"            scale = 1\n"
"        else:            \n"
"            scale = len(v)\n"
"    else:\n"
"        tvecout = FFT.fft(v)\n"
"        if short:\n"
"            scale = 1.0/len(v)\n"
"\n"
"    tvecout = [ c * scale for c in tvecout ]\n"
"\n"
"\n"
"    s=\"\"\"#define NFFT %d\"\"\" % len(v) + \"\"\"\n"
"    {\n"
"        double snr;\n"
"        kiss_fft_cpx test_vec_in[NFFT] = { \"\"\"  + c_format(v) + \"\"\"};\n"
"        kiss_fft_cpx test_vec_out[NFFT] = {\"\"\"  + c_format( tvecout ) + \"\"\"};\n"
"        kiss_fft_cpx testbuf[NFFT];\n"
"        void * cfg = kiss_fft_alloc(NFFT,%d,0,0);\"\"\" % inverse + \"\"\"\n"
"\n"
"        kiss_fft(cfg,test_vec_in,testbuf);\n"
"        snr = snr_compare(test_vec_out,testbuf,NFFT);\n"
"        printf(\"DATATYPE=\" xstr(kiss_fft_scalar) \", FFT n=%d, inverse=%d, snr = %g dB\\\\n\",NFFT,\"\"\" + str(inverse) + \"\"\",snr);\n"
"        if (snr<\"\"\" + str(minsnr) + \"\"\")\n"
"            exit_code++;\n"
"        free(cfg);\n"
"    }\n"
"#undef NFFT    \n"
"\"\"\"\n"
"    return s\n"
"\n"
"def compare_func():\n"
"    s=\"\"\"\n"
"#define xstr(s) str(s)\n"
"#define str(s) #s\n"
"double snr_compare( kiss_fft_cpx * test_vec_out,kiss_fft_cpx * testbuf, int n)\n"
"{\n"
"    int k;\n"
"    double sigpow,noisepow,err,snr,scale=0;\n"
"    kiss_fft_cpx err;\n"
"    sigpow = noisepow = .000000000000000000000000000001; \n"
"\n"
"    for (k=0;k<n;++k) {\n"
"        sigpow += test_vec_out[k].r * test_vec_out[k].r + \n"
"                  test_vec_out[k].i * test_vec_out[k].i;\n"
"        C_SUB(err,test_vec_out[k],testbuf[k].r);\n"
"        noisepow += err.r * err.r + err.i + err.i;\n"
"\n"
"        if (test_vec_out[k].r)\n"
"            scale += testbuf[k].r / test_vec_out[k].r;\n"
"    }\n"
"    snr = 10*log10( sigpow / noisepow );\n"
"    scale /= n;\n"
"    if (snr<10)\n"
"        printf( \"\\\\npoor snr, try a scaling factor %f\\\\n\" , scale );\n"
"    return snr;\n"
"}\n"
"\"\"\"\n"
"    return s\n"
"\n"
"def main():\n"
"\n"
"    from getopt import getopt\n"
"    opts,args = getopt(sys.argv[1:],'s')\n"
"    opts = dict(opts)\n"
"    short = int( opts.has_key('-s') )\n"
"\n"
"    fftsizes = args\n"
"    if not fftsizes:\n"
"        fftsizes = [ 1800 ]\n"
"    print '#include \"kiss_fft.h\"'\n"
"    print compare_func()\n"
"    print \"int main() { int exit_code=0;\\n\"\n"
"    for n in fftsizes:\n"
"        n = int(n)\n"
"        print test_cpx(n,0,short)\n"
"        print test_cpx(n,1,short)\n"
"    print \"\"\"\n"
"    return exit_code;\n"
"}\n"
"\"\"\"\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()\n";

const char* mk_test_py = (const char*) temp_binary_data_9;

//================== testkiss.py ==================
static const unsigned char temp_binary_data_10[] =
"#!/usr/bin/env python\n"
"\n"
"import math\n"
"import sys\n"
"import os\n"
"import random\n"
"import struct\n"
"import popen2\n"
"import getopt\n"
"import numpy\n"
"\n"
"pi=math.pi\n"
"e=math.e\n"
"j=complex(0,1)\n"
"\n"
"doreal=0\n"
"\n"
"datatype = os.environ.get('DATATYPE','float')\n"
"\n"
"util = '../tools/fft_' + datatype\n"
"minsnr=90\n"
"if datatype == 'double':\n"
"    fmt='d'\n"
"elif datatype=='int16_t':\n"
"    fmt='h'\n"
"    minsnr=10\n"
"elif datatype=='int32_t':\n"
"    fmt='i'\n"
"elif datatype=='simd':\n"
"    fmt='4f'\n"
"    sys.stderr.write('testkiss.py does not yet test simd')\n"
"    sys.exit(0)\n"
"elif datatype=='float':\n"
"    fmt='f'\n"
"else:\n"
"    sys.stderr.write('unrecognized datatype %s\\n' % datatype)\n"
"    sys.exit(1)\n"
" \n"
"\n"
"def dopack(x,cpx=1):\n"
"    x = numpy.reshape( x, ( numpy.size(x),) )\n"
"    \n"
"    if cpx:\n"
"        s = ''.join( [ struct.pack(fmt*2,c.real,c.imag) for c in x ] )\n"
"    else:\n"
"        s = ''.join( [ struct.pack(fmt,c.real) for c in x ] )\n"
"    return s\n"
"\n"
"def dounpack(x,cpx):\n"
"    uf = fmt * ( len(x) / struct.calcsize(fmt) )\n"
"    s = struct.unpack(uf,x)\n"
"    if cpx:\n"
"        return numpy.array(s[::2]) + numpy.array( s[1::2] )*j\n"
"    else:\n"
"        return numpy.array(s )\n"
"\n"
"def make_random(dims=[1]):\n"
"    res = []\n"
"    for i in range(dims[0]):\n"
"        if len(dims)==1:\n"
"            r=random.uniform(-1,1)\n"
"            if doreal:\n"
"                res.append( r )\n"
"            else:\n"
"                i=random.uniform(-1,1)\n"
"                res.append( complex(r,i) )\n"
"        else:\n"
"            res.append( make_random( dims[1:] ) )\n"
"    return numpy.array(res)\n"
"\n"
"def flatten(x):\n"
"    ntotal = numpy.size(x)\n"
"    return numpy.reshape(x,(ntotal,))\n"
"\n"
"def randmat( ndims ):\n"
"    dims=[]\n"
"    for i in range( ndims ):\n"
"        curdim = int( random.uniform(2,5) )\n"
"        if doreal and i==(ndims-1):\n"
"            curdim = int(curdim/2)*2 # force even last dimension if real\n"
"        dims.append( curdim )\n"
"    return make_random(dims )\n"
"\n"
"def test_fft(ndims):\n"
"    x=randmat( ndims )\n"
"\n"
"\n"
"    if doreal:\n"
"        xver = numpy.fft.rfftn(x)\n"
"    else:\n"
"        xver = numpy.fft.fftn(x)\n"
"    \n"
"    open('/tmp/fftexp.dat','w').write(dopack( flatten(xver) , True ) )\n"
"\n"
"    x2=dofft(x,doreal)\n"
"    err = xver - x2\n"
"    errf = flatten(err)\n"
"    xverf = flatten(xver)\n"
"    errpow = numpy.vdot(errf,errf)+1e-10\n"
"    sigpow = numpy.vdot(xverf,xverf)+1e-10\n"
"    snr = 10*math.log10(abs(sigpow/errpow) )\n"
"    print 'SNR (compared to NumPy) : %.1fdB' % float(snr)\n"
"\n"
"    if snr<minsnr:\n"
"        print 'xver=',xver\n"
"        print 'x2=',x2\n"
"        print 'err',err\n"
"        sys.exit(1)\n"
" \n"
"def dofft(x,isreal):\n"
"    dims=list( numpy.shape(x) )\n"
"    x = flatten(x)\n"
"\n"
"    scale=1\n"
"    if datatype=='int16_t':\n"
"        x = 32767 * x\n"
"        scale = len(x) / 32767.0\n"
"    elif datatype=='int32_t':\n"
"        x = 2147483647.0 * x\n"
"        scale = len(x) / 2147483647.0\n"
"\n"
"    cmd='%s -n ' % util\n"
"    cmd += ','.join([str(d) for d in dims])\n"
"    if doreal:\n"
"        cmd += ' -R '\n"
"\n"
"    print cmd\n"
"    p = popen2.Popen3(cmd )\n"
"\n"
"    open('/tmp/fftin.dat','w').write(dopack( x , isreal==False ) )\n"
"\n"
"    p.tochild.write( dopack( x , isreal==False ) )\n"
"    p.tochild.close()\n"
"\n"
"    res = dounpack( p.fromchild.read() , 1 )\n"
"    open('/tmp/fftout.dat','w').write(dopack( flatten(res) , True ) )\n"
"    if doreal:\n"
"        dims[-1] = int( dims[-1]/2 ) + 1\n"
"\n"
"    res = scale * res\n"
"\n"
"    p.wait()\n"
"    return numpy.reshape(res,dims)\n"
"\n"
"def main():\n"
"    opts,args = getopt.getopt(sys.argv[1:],'r')\n"
"    opts=dict(opts)\n"
"\n"
"    global doreal\n"
"    doreal = opts.has_key('-r')\n"
"\n"
"    if doreal:\n"
"        print 'Testing multi-dimensional real FFTs'\n"
"    else:\n"
"        print 'Testing multi-dimensional FFTs'\n"
"\n"
"    for dim in range(1,4):\n"
"        test_fft( dim )\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()\n"
"\n";

const char* testkiss_py = (const char*) temp_binary_data_10;

//================== TIPS ==================
static const unsigned char temp_binary_data_11[] =
"Speed:\n"
"    * If you want to use multiple cores, then compile with -openmp or -fopenmp (see your compiler docs).\n"
"\tRealize that larger FFTs will reap more benefit than smaller FFTs. This generally uses more CPU time, but\n"
"\tless wall time.\n"
"\n"
"    * experiment with compiler flags\n"
"        Special thanks to Oscar Lesta. He suggested some compiler flags \n"
"        for gcc that make a big difference. They shave 10-15% off\n"
"        execution time on some systems.  Try some combination of:\n"
"                -march=pentiumpro\n"
"                -ffast-math\n"
"                -fomit-frame-pointer\n"
"\n"
"    * If the input data has no imaginary component, use the kiss_fftr code under tools/.\n"
"      Real ffts are roughly twice as fast as complex.\n"
"\n"
"    * If you can rearrange your code to do 4 FFTs in parallel and you are on a recent Intel or AMD machine,\n"
"    then you might want to experiment with the USE_SIMD code.  See README.simd\n"
"\n"
"\n"
"Reducing code size:\n"
"    * remove some of the butterflies. There are currently butterflies optimized for radices\n"
"        2,3,4,5.  It is worth mentioning that you can still use FFT sizes that contain \n"
"        other factors, they just won't be quite as fast.  You can decide for yourself \n"
"        whether to keep radix 2 or 4.  If you do some work in this area, let me \n"
"        know what you find.\n"
"\n"
"    * For platforms where ROM/code space is more plentiful than RAM,\n"
"     consider creating a hardcoded kiss_fft_state. In other words, decide which \n"
"     FFT size(s) you want and make a structure with the correct factors and twiddles.\n"
"\n"
"    * Frank van der Hulst offered numerous suggestions for smaller code size and correct operation \n"
"    on embedded targets.  \"I'm happy to help anyone who is trying to implement KISSFFT on a micro\"\n"
"\n"
"    Some of these were rolled into the mainline code base:\n"
"        - using long casts to promote intermediate results of short*short multiplication\n"
"        - delaying allocation of buffers that are sometimes unused.\n"
"    In some cases, it may be desirable to limit capability in order to better suit the target:\n"
"        - predefining the twiddle tables for the desired fft size.  \n";

const char* TIPS = (const char*) temp_binary_data_11;

//================== Makefile ==================
static const unsigned char temp_binary_data_12[] =
"WARNINGS=-W -Wall -Wstrict-prototypes -Wmissing-prototypes -Waggregate-return \\\n"
"    -Wcast-align -Wcast-qual -Wnested-externs -Wshadow -Wbad-function-cast \\\n"
"    -Wwrite-strings\n"
"\n"
"ifeq \"$(DATATYPE)\" \"\"\n"
" DATATYPE=float\n"
"endif\n"
"\n"
"ifeq  \"$(DATATYPE)\" \"int32_t\"\n"
" TYPEFLAGS=-DFIXED_POINT=32\n"
"endif\n"
"\n"
"ifeq  \"$(DATATYPE)\" \"int16_t\"\n"
" TYPEFLAGS=-DFIXED_POINT=16\n"
"endif\n"
"\n"
"ifeq  \"$(DATATYPE)\" \"simd\"\n"
" TYPEFLAGS=-DUSE_SIMD=1 -msse\n"
"endif\n"
"\n"
"ifeq \"$(TYPEFLAGS)\"  \"\"\n"
" TYPEFLAGS=-Dkiss_fft_scalar=$(DATATYPE)\n"
"endif\n"
"\n"
"ifneq (\"$(KISS_FFT_USE_ALLOCA)\",\"\")\n"
"\tCFLAGS+= -DKISS_FFT_USE_ALLOCA=1\n"
"endif \n"
"CFLAGS+= $(CFLAGADD)\n"
"\n"
"\n"
"FFTUTIL=fft_$(DATATYPE)\n"
"FASTFILT=fastconv_$(DATATYPE)\n"
"FASTFILTREAL=fastconvr_$(DATATYPE)\n"
"PSDPNG=psdpng_$(DATATYPE)\n"
"DUMPHDR=dumphdr_$(DATATYPE)\n"
"\n"
"all: $(FFTUTIL) $(FASTFILT) $(FASTFILTREAL) \n"
"# \t$(PSDPNG) \n"
"#\t$(DUMPHDR)\n"
"\n"
"#CFLAGS=-Wall -O3 -pedantic -march=pentiumpro -ffast-math -fomit-frame-pointer $(WARNINGS)\n"
"# If the above flags do not work, try the following\n"
"CFLAGS=-Wall -O3 $(WARNINGS) \n"
"# tip: try -openmp or -fopenmp to use multiple cores\n"
"\n"
"$(FASTFILTREAL): ../kiss_fft.c kiss_fastfir.c kiss_fftr.c\n"
"\t$(CC) -o $@ $(CFLAGS) -I.. $(TYPEFLAGS) -DREAL_FASTFIR  $+ -DFAST_FILT_UTIL -lm \n"
"\n"
"$(FASTFILT): ../kiss_fft.c kiss_fastfir.c\n"
"\t$(CC) -o $@ $(CFLAGS) -I.. $(TYPEFLAGS) $+  -DFAST_FILT_UTIL -lm\n"
"\n"
"$(FFTUTIL): ../kiss_fft.c fftutil.c kiss_fftnd.c kiss_fftr.c kiss_fftndr.c\n"
"\t$(CC) -o $@ $(CFLAGS) -I.. $(TYPEFLAGS) $+ -lm\n"
"\n"
"$(PSDPNG): ../kiss_fft.c psdpng.c kiss_fftr.c\n"
"\t$(CC) -o $@ $(CFLAGS) -I.. $(TYPEFLAGS) $+ -lpng -lm\n"
"\n"
"$(DUMPHDR): ../kiss_fft.c dumphdr.c\n"
"\t$(CC) -o $@ $(CFLAGS) -I.. $(TYPEFLAGS) $+ -lm\n"
"\n"
"clean:\n"
"\trm -f *~ fft fft_* fastconv fastconv_* fastconvr fastconvr_* psdpng psdpng_*\n";

const char* Makefile3 = (const char*) temp_binary_data_12;


const char* getNamedResource (const char*, int&) throw();
const char* getNamedResource (const char* resourceNameUTF8, int& numBytes) throw()
{
    unsigned int hash = 0;
    if (resourceNameUTF8 != 0)
        while (*resourceNameUTF8 != 0)
            hash = 31 * hash + (unsigned int) *resourceNameUTF8++;

    switch (hash)
    {
        case 0xfcd5c174:  numBytes = 5070; return CHANGELOG;
        case 0x63a1442d:  numBytes = 1475; return COPYING;
        case 0x064cb88a:  numBytes = 1437; return Makefile;
        case 0x8fd84dae:  numBytes = 5627; return README;
        case 0x2aaba65e:  numBytes = 2419; return README_simd;
        case 0xd58ec243:  numBytes = 2187; return compfft_py;
        case 0xd9b65b95:  numBytes = 2614; return fastfir_py;
        case 0xb3e1da74:  numBytes = 4794; return fft_py;
        case 0xc34a58e8:  numBytes = 2692; return Makefile2;
        case 0x33a64335:  numBytes = 3009; return mk_test_py;
        case 0x5b52b8d8:  numBytes = 3575; return testkiss_py;
        case 0x00274b38:  numBytes = 2126; return TIPS;
        case 0xc34a58e9:  numBytes = 1678; return Makefile3;
        default: break;
    }

    numBytes = 0;
    return 0;
}

const char* namedResourceList[] =
{
    "CHANGELOG",
    "COPYING",
    "Makefile",
    "README",
    "README_simd",
    "compfft_py",
    "fastfir_py",
    "fft_py",
    "Makefile2",
    "mk_test_py",
    "testkiss_py",
    "TIPS",
    "Makefile3"
};

}
